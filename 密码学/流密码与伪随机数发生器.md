# 流密码与伪随机数发生器

## 数学上的基本概念

从这章开始，我们就不再拘泥于古代的加密拉丁字母的加密方式，而开始转向数字化。我们知道，在现代科技中，密码学最常应用的领域就是计算机领域，而计算机领域则是由二进制的$0, 1$串构成。因此，在接下来的讨论中，我们都将明文空间及密文空间看作由$0$和$1$构成的二进制串组成的集合。

因此，为了接下来能更顺畅地进行关于流密码的讨论，这里先介绍一些数学上关于这方面的基础知识。

### $\GF({2}$上的加法与乘法

由于我们讨论的仅是$0$和$1$及它们的运算,
因此，我们定义一个有限域$\GF({2}=\brace{0, 1}$.

有限域$\GF({2}$上的加法被定义成逻辑上的异或，也可以理解成模$2$加法。以下为$\GF({2}$上的加法表：

   $+$   0   1
  ----- --- ---
    0    0   1
    1    1   0

  : $\GF({2}$上的加法表

如果我们定义一个集合中元素$a$的加法逆元$-a$满足
$$a+({-a}=({-a}+a=0$$

则$\GF({2}$上的加法逆元表为：

   $a$    0   1
  ------ --- ---
   $-a$   0   1

  : $\GF({2}$上的加法逆元表

而$\GF({2}$上的减法则可以定义成与加法逆元的加法，即
$$a-b=a+({-b}$$

$\GF({2}$上的乘法则被定义成了逻辑上的与。以下为$\GF({2}$上的乘法表：

   $\cdot$   0   1
  --------- --- ---
      0      0   0
      1      0   1

  : $\GF({2}$上的乘法表

根据上述的定义，我们可以得出以下$\GF({2}$上常用的运算规则：

-   $$\forall x\in\GF({2}, x+x=0$$

-   $$\forall x, y\in\GF({2}, x-y=y-x=x+y$$

-   $$\forall x\in\GF({2}, x\cdot x=x$$

### $\GF({2}$上的多项式

此外，还有一个我们未曾接触过的知识：$\GF({2}$上的多项式。为此，不妨先介绍一下多项式理论。

对于表达式 $$a_nx^n+a_{n-1}x^{n-1}+\cdots +a_1x+a_0=\sum_{i=0}^na_ix_i$$

我们称其系数为$a_0, a_1,\ldots, a_n$.
其系数集$S$为$a_0, a_1,\ldots ,a_n$的取值范围。当$a_n\neq 0$时，称该多项式为$S$上的$n$次多项式。比如说，如果其系数的取值仅限于$0$和$1$,
则称这个多项式为$\GF({2}$上的多项式。

值得指出的是，我们研究多项式理论时，多项式在我们眼中仅仅是一个表达式，我们并不需要去对每一个$x$的取值进行多项式的求值。它就相当于一个集合的元素，一个多项式就是一个最小的单位。其加、减、乘、除就应该像我们定义复数集那样重新地进行定义。也就是说，我们通过定义来确定多项式$f+g=h$,
而不是通过$\forall x, h(x)=f(x)+g(x)$来定义多项式之和。尽管结果确实如此，但这应该理解为自洽的定义，而非推导。

#### 多项式的加法

两个多项式之和的多项式的系数，等于其对应系数之和。即：

若$m\geq n$, 则
$$\sum_{i=0}^ma_ix^i+\sum_{j=0}^nb_jx^j=\sum_{k=0}^n({a_k+b_k}x^k+\sum_{i=n+1}^ma_ix^i$$
其中$a_k+b_k$的加法应理解成系数集$S$上的加法。

用更形象的方法来说，我们不妨考虑实数集上的多项式$f=x^2+1$与$g=x^3+x^2$,
那么其和我们可以类似于小学时的竖式来计算：

  ------- ----- ------- ----- -------- ----- -----
    $f$    $=$                   $x^2$  $+$    $1$
    $g$    $=$    $x^3$  $+$     $x^2$  $+$    $1$
   $f+g$   $=$    $x^3$  $+$    $2x^2$  $+$    $2$
  ------- ----- ------- ----- -------- ----- -----

但是，我们这里也需要注意到刚刚说的，$a_k+b_k$的加法应理解成系数集$S$上的加法。比如说还是刚刚的两个多项式，但其在$\GF({2}$上的加法为：

  ------- ----- ------- ----- ------- ----- -----
    $f$    $=$                  $x^2$  $+$    $1$
    $g$    $=$    $x^3$  $+$    $x^2$  $+$    $1$
   $f+g$   $=$    $x^3$                     
  ------- ----- ------- ----- ------- ----- -----

这里$2x^2$与$2$之所以不见了，是因为在$\GF({2}$上，$1+1=0$.

#### 多项式的减法

类似于多项式的加法的定义，两个多项式之差的系数，等于其对应系数之差。在$\GF({2}$上的多项式之差的例子：

  ------- ----- ------- ----- ------- ----- -----
    $f$    $=$                  $x^2$  $+$    $1$
    $g$    $=$    $x^3$  $+$    $x^2$  $+$    $1$
   $f-g$   $=$    $x^3$                     
  ------- ----- ------- ----- ------- ----- -----

这里是由于$({0-1}x^3=({0+1}x^3=x^3$, $({1-1}x^2=0$, $1-1=0$.

#### 多项式的乘法

我们可以形式上地用乘法分配律进行计算，并且约定$x^ix^j=x^{i+j}$.
下面演示一下$\GF({2}$上多项式的乘法运算： $$\begin{aligned}
    &({x+1}({x+1}\\
    =&xx+({1+1}x+1\\
    =&x^2+1
\end{aligned}$$ 注意到在$\GF({2}$上，$({1+1}x=0$.

同时，我们记$f^n=f\cdot f^{n-1}$.

#### 多项式的整除

对于多项式$f$和$g$, 如果存在多项式$h$, 使得$f=gh$, 则称$g$整除$f$,
记作$g\mid f$, 同时$\ext \frac{f}{g}=h$.

注意这仍是在系数集$S$上的。比如说，在$\GF({2}$中，我们有
$$({x^2+1}\mid({x+1}^2$$

此外，若一个多项式$f$是不可约的，则说明不存在两个多项式$g, h$,
使得$gh=f$且$g, h$的次数均小于$f$的次数。

#### $\GF({2}$上的常用等式

加法交换律 $$f+g=g+f$$

加法结合律 $$({f+g}+h=f+({g+h}$$

乘法交换律 $$fg=gf$$

乘法结合律 $$({fg}h=f({gh}$$

乘法对加法的分配律 $$f({g+h}=fg+fh$$

等比数列求和公式：对于多项式$f$和$g\neq 1$
$$f+gf+fg^2+\cdots +fg^{n-1}=\sum_{i=0}^{n-1}fg^{i}=\frac{f-fg^{n}}{1-g}$$

#### 总结

在$\GF({2}$这个有限域上的运算和我们在实数集上的运算很不一样，所以在后文中我们应该着重注意运算是定义在$\GF({2}$上的还是定义在实数集上的。同时，我们也该清楚定理叙述的是多项式之间的关系还是值之间的关系。

## 流密码的基本概念

之前我们讲到"一次一密"的加密方式是完善保密，同时，"一次一密"的缺点也十分显著：密钥过长。那么，有什么办法能规避这样的缺点呢？事实上，"一次一密"的加密方式之所以是完善保密的，最重要的一点是每次密钥的字符串是随机生成的。通过之前讲的香农定理我们可以知道，每个密钥字符串生成的概率均是相等的。如果我们可以降低一点这种随机性的要求，那也许就能实现短密钥+强保密的目标。

为此，我们引入**伪随机数序列**的概念。由于这个概念的严格定义需要高超的概率论及算法知识，我们只需要感性地理解伪随机数序列为一种，由确定的算法产生的（即相同的初始条件下的输出是相同的），与真随机数序列性质几乎一样的序列。

那么**流密码**的工作模式可以简单地看作：对于给定长度的一串明文$M=m_1m_2\cdots m_n$,
我们输入密钥$k$,
通过某种算法产生一个同样长度的伪随机序列$Z=z_1z_2\cdots z_n$作为密钥流,
输出结果$Y=y_1y_2\cdots y_n$为明文串与伪随机序列按位异或的结果$y_i=m_i\oplus z_i$.
根据之前在$\GF({2}$上的讨论，解密算法也是将密文串与密钥流进行按位异或，即$m_i=y_i\oplus z_i$.

根据上述的定义，流密码与一次一密的区别就在于，在与明文串进行按位异或的过程中，一次一密使用的是真随机序列，流密码使用的是伪随机序列。如何能使伪随机序列的表现足够像真随机序列，则是流密码安全性的关键。因此，对流密码的研究，主要就在于产生伪随机序列的算法上。

设$f(k, \sigma_i)$为一个能产生伪随机序列的算法，其中$k$为输入的密钥，$\sigma_i$为当前时刻系统的状态。在每个时刻，$f(k, \sigma_i)$输出一个伪随机数，同时系统状态改变为$\sigma_{i+1}$.
常把一个用于加密算法的伪随机序列称为**密钥流**，产生伪随机序列的算法称为**密钥流生成器**。

之前在讲到密钥流生成器的时候，我们提到了系统当前的状态$\sigma_i$.
这里的状态，是根据当前的输入和输出而变化的。每输入一个数，密钥流生成器每输出一个数，当前系统的状态就发生了变化。之后会介绍一些具体的例子让大家更加理解"系统的状态"的含义。在这里，我们将流密码分为同步流密码和自同步流密码。如果密钥流生成器中的状态与输入的明文有关，则称为**自同步流密码**，反之则称为**同步流密码**。同步流密码中，伪随机序列与明文无关，因此，可以独立出来作为单独的部件，其称为**伪随机比特发生器(PRBG)**。对于自同步流密码，可以参看之后分组密码的CFB模式。

那么流密码的过程可以理解为：如果设明文为二进制串$X=x_1x_2\cdots x_n$,
密钥为$k$. 在初始状态下，输入$x_1$和$k$,
伪随机数发生器根据当前的状态输出一个伪随机数$z_1$,
输出密文$y_1=x_1\oplus z_1$. 接着输入$x_2$,
密钥流生成器根据当前的状态输出一个伪随机数$z_2$,
输出密文$y_2=x_2\oplus z_2$. 以此类推。

流密码本身并没有太多的技巧，但是，伪随机比特发生器在密码学中则有许多作用。所以，下面我们主要讨论一下各种伪随机比特发生器。

## 基于LFSR的伪随机比特发生器

为了生成近似真随机的伪随机序列，基于LFSR的伪随机数发生器由线性部分和非线性部分组合。

### 伪随机比特发生器的线性部分

#### LFSR

根据上述的讨论，伪随机数发生器应有两个功能：输出密钥流与更新系统状态。伪随机数发生器的线性部分也有两个功能：输出中间的过渡字符，并且更新系统状态。所谓中间的过渡字符，意思是该部分的输出并非作为最终输出的伪随机数，而是一个中间用于之后计算的数。

常见的处理方法为：系统的状态$\sigma_i=a_{n, i}a_{n-1, i}\cdots a_{1, i}$由$n$个二进制数构成。在启动之前，具有初始状态$a_{n, 0}a_{n-1, 0}\cdots a_{1, 0}$.
之后，每次的输出$b_i$为 $$b_i=a_{1, i-1}$$

而状态更新的方法为
$$a_{j, i}=\begin{dcases}a_{j+1, i}&1\leq j\leq n-1\\f({a_{1, i-1}, a_{2, i-1}, \ldots, a_{n, i-1}}&j=n\end{dcases}$$

其中**反馈函数**$f({a_{1, i-1}, a_{2, i-1}, \ldots, a_{n, i-1}}$是一个$\GF({2}$上的线性函数。即：
$$\begin{aligned}
    a_{n, i}&=f({a_{1, i-1}, a_{2, i-1}, \ldots, a_{n, i-1}}\notag\\
    &=c_na_{1, i-1}+c_{n-1}a_{2, i-1}+\cdots +c_1a_{n, i-1}\\
    &=\sum_{k=1}^nc_{n+1-k}a_{k, i-1}
\end{aligned}$$ 其中$c_k\in\GF({2}$, 即$c_k$的取值为$0$或$1$.
这些数字都是固定的，由伪随机数发生器本身决定。而这里的加法、乘法运算均为$\GF({2}$上的运算。

我们通过一个例子来熟悉：

设初始状态为$110$,
反馈函数$f(a_{3, i}, a_{2, i}, a_{1, i})=a_{3, i}+a_{1, i}$.
则我们可以通过下表来了解这个线性部分的输出：

          $i$           0   1   2   3   4   5   6   7   $\cdots$
  -------------------- --- --- --- --- --- --- --- --- ----------
   $f(a_3, a_2, a_1)$   1   0   1   0   0   1   1   1   $\cdots$
         $a_3$          1   1   0   1   0   0   1   1   $\cdots$
         $a_2$          1   1   1   0   1   0   0   1   $\cdots$
         $a_1$          0   1   1   1   0   1   0   0   $\cdots$
          $b$               0   1   1   1   0   1   0   $\cdots$

其输出序列就为$011101\quad 011101\cdots$.

我们由上面的表可以发现，从每一列来看，随着$i$的递增，上一行的数会传给下一行的数。这似乎是某种线性寄存器的工作形式。因此，我们称伪随机数发生器的线性部分为一个**线性反馈移位寄存器**(Linear
Feedback Shift Register, LFSR).
若其状态具有$n$个二进制数字，且$c_n\neq 0$, 则称其为$n$级LFSR.

#### LFSR的输出序列

如果设$B=b_1b_2\cdots b_i\cdots$表示LFSR的输出序列，则由上述的讨论也可以知道
$$({b_{i+1}b_{i+2}\cdots b_{i+n}}=({a_{1, i-1}a_{2, i-1}\cdots a_{n, i-1}}$$

我们还可以认为，每一个$b_i$都可以代表LFSR的一个状态。那么，由于LFSR的一个状态中有$n$个二进制数，故一个LFSR至多有$2^n$种状态。如果称状态$\sigma=00\cdots 0$为零状态，下面我们证明：零状态的下一个状态是零状态，任何非零状态的下一个状态均不是零状态。

```prove
前半句话显然，设$\forall 1\leq j\leq n, a_{j, i}=0$. 对于$j\leq n-1$,
$a_{j, i+1}=a_{j+1, i}=0$. 而
$$a_{n, i}=c_na_{1, i-1}+c_{n-1}a_{2, i-1}+\cdots +c_1a_{n, i-1}=0$$

对于后半句话，若某个非零状态$\sigma_i=a_{n, i}a_{n-1, i}\cdots a_{1, i}$的下一个状态为零状态，则由定义可知，$\forall 2\leq j\leq n, a_{j, i}=a_{j-1, i+1}=0, a_{n, i+1}\neq 0$.
且
$$0=a_{n, i+1}=c_na_{1, i}+c_{n-1}a_{2, i}+\cdots +c_1a_{n, i}=c_na_{1, i}$$

又由于$c_n\neq 0$, 故$a_{1, i}=0$矛盾。
```

由上述讨论可知，一个LFSR中的状态，至多$2^n-1$个之后即达成循环。也就是说，一个LFSR产生的序列，周期至多为$2^n-1$.

::: Definition
我们称由LFSR产生的周期为$2^n-1$的序列为一个$m$序列。
:::

#### $m$序列相关定理

上述的讨论中，我们提到，反馈函数
$$a_{n, i}=c_na_{1, i-1}+c_{n-1}a_{2, i-1}+\cdots +c_1a_{n, i-1}$$
中的$c_1, c_2,\ldots ,c_n$由LFSR本身决定。因此：

::: Definition
我们称$\GF({2}$上的多项式
$$p(x)=1+c_1x+\cdots +c_{n-1}x^{n-1}+c_nx^n$$ 为LFSR的特征多项式。

对于LFSR生成的一个序列$a_1a_2\cdots a_n\cdots$, 称幂级数
$$A({x}=\sum_{i=1}^{\infty}a_ix^{i-1}$$ 为该序列的生成函数。

对于使用给定的LFSR,
由于初始状态不同而产生的所有$2^n-1$个非零序列构成的集合记作$G({p({x}}$.
:::

下面叙述一个在证明中很有用的定理：

::: theorem
设LFSR的特征多项式$p(x)=1+c_1x+\cdots +c_{n-1}x^{n-1}+c_nx^n$,
$A({x}$为$G({p(x)}$中任意序列$\brace{a_n}$的生成函数，则对于$\GF({2}$上的多项式$p(x)$和$A(x)$,
满足 $$A(x)=\frac{\phi(x)}{p(x)}$$

其中 $$\phi(x)=\sum_{i=1}^n({c_{n-i}x^{n-i}\sum_{j=1}^ia_jx^{j-1}}$$
:::

我们可以对$\phi(x)$进行展开： $$\begin{aligned}
    \phi(x)&=\sum_{i=1}^n({c_{n-i}x^{n-i}\sum_{j=1}^ia_jx^{j-1}}\\
    &=\sum_{i=1}^n({\sum_{j=1}^ic_{n-i}a_jx^{n-i+j-1}}\\
    &\xlongequal{k=n-i+j-1}\sum_{i=1}^n\sum_{k=n-i}^{n-1}c_{n-i}a_{k-n+i+1}x^k
\end{aligned}$$

因此，我们可以发现，$\phi(x)$的次数不超过$n-1$.

::: Definition
对于$\GF({2}$上的多项式$p(x)$, 若$p(x)\mid x^p-1$,
则称最小的$p$为$p(x)$的阶。
:::

一个与之相关的定理是：

::: theorem
设$p(x)$是$n$次不可约多项式，其阶为$m$.
则$\forall \brace{a_n}\in G({p(x)}$, $\brace{a_n}$的周期为$m$.
:::

::: Definition
若$n$次不可约多项式$p(x)$的阶为$2^{n}-1$, 则称$p(x)$是本原多项式。
:::

下面叙述的是最关键的一个定理：

::: theorem
设$\brace{a_n}\in G({p(x)}$,
则$\brace{a_n}$为$m$序列的充要条件是$p(x)$是本原多项式。
:::

#### LFSR是伪随机比特产生器

为了叙述本节的定理，我们引入两个概念：

::: Definition
对于序列$\brace{a_n}$,
长度最大为$n$的连续的0或者1称为一个长度为$n$的0游程或1游程。

对于$\GF({2}$上周期为$2$的序列$\brace{a_n}$, 称其异相关函数为
$$R({\tau}=\frac{1}{T}\sum_{k=1}^T({-1}^{a_k}({-1}^{a_{k+\tau}}, 0<\tau\leq T-1$$
:::

之前我们提到的伪随机数序列，我们在这里给出一种定义方法：

::: Definition
对于周期序列$\brace{a_n}$, 其为伪随机序列的条件为

1.  在序列的一个周期内，$0$与$1$的个数至多相差1.

2.  在序列的一个周期内，长为$i$的游程占游程总数的$\ext\frac{1}{2^i}$,
    且其中0游程与1游程个数相等。

3.  该序列的异相关函数是个常数。
:::

那么我们可以证明，一个$n$长$m$序列是这种意义下的伪随机序列。

#### LFSR密码的破译

在本节介绍的破译方式中，值得强调的是，敌手是知道LFSR为$n$级，且敌手获得了一串长度为$2n$的明密文对。

假设敌手获得的明密文对为$x_1x_2\cdots x_{2n}$和$y_1y_2\cdots y_{2n}$,
其需要破译的是LFSR的特征多项式的系数$c_1, c_2,\ldots, c_n$.
那么由于在$\GF({2}$上 $$y_i=x_i+z_i$$
其中$z_i$为产生的密钥流的第$i$位。

故在$\GF({2}$上 $$x_i+y_i=x_i+x_i+z_i=z_i$$

从而敌手就获得了一段长度为$2n$的密钥流$z_1z_2\cdots z_{2n}$.

如果记
$$S_i=({z_{i+1}, z_{i+2}, \ldots, z_{i+n}}^{\mathrm{T}}, i=0, 1,\ldots, n-1$$

且 $$X=({S_0,S_1,\ldots, S_{n-1}}$$

故根据表达式 $$z_{n+i}=c_nz_{i}+c_{n-1}z_{i+1}+\cdots +c_{1}z_{i+n-1}$$

可得：
$$({z_{n+1}, z_{n+2},\ldots, z_{2n}}=({c_n, c_{n-1}, \cdots ,c_{1}}X$$

而我们可以证明$X$是可逆的。故
$$({c_n, c_{n-1}, \cdots ,c_{1}}=({z_{n+1}, z_{n+2},\ldots, z_{2n}}X^{-1}$$

### 伪随机比特发生器的非线性部分

由上述的讨论我们可以发现，线性的伪随机数发生器产生的密钥流一定是周期的。而周期较短的密钥流则相当于一种多表代换密码，相对容易破解。因此，只有加上非线性的部分来处理，才能提高安全性。

伪随机数发生器的非线性部分的主要工作是接受一个或多个LFSR的输入，以非线性的方式，输出密钥流。

我们综合判定一个输出密钥流的优劣，可以从两个方面：周期和线性复杂度。周期越长，线性复杂度越高的密钥流越安全。周期我们可以直接衡量，而线性复杂度我们该如何衡量呢？我们称一个序列的线性复杂度为生成该序列的最短LFSR的级数。即若该序列周期$T$满足$2^{n-1}-1<T\leq 2^{n}-1$,
则该序列的线性复杂度为$n$.

#### Geffe序列生成器

Geffe序列生成器接受三个LFSR的输入，其输入分别为序列$\brace{a_n^{(1)}}, \brace{a_n^{(2)}}, \brace{a_n^{(3)}}$.

其输出序列$\brace{b_k}$可以表示为

   $a_k^{(2)}$      $b_k$
  ------------- -------------
       $0$       $a_k^{(3)}$
       $1$       $a_k^{(1)}$

若$\brace{a_n^{(1)}}$,
$\brace{a_n^{(2)}}$和$\brace{a_n^{(3)}}$的周期分别为$2^{n_1}-1$,
$2^{n_2}-1$和$2^{n_3}-1$且$n_1, n_2, n_3$两两互素，则$\brace{b_k}$的周期为$({2^{n_1}-1}({2^{n_2}-1}({2^{n_3}-1}$,
线性复杂度为$({n_1+n_3}n_2+n_3$

#### JK触发器

JK触发器接受两个LFSR的输入，其输入分别为序列$\brace{a_n^{(1)}}, \brace{a_n^{(2)}}$.

其输出序列$\brace{b_k}$可以表示为

   $a_k^{(1)}$   $a_k^{(2)}$          $b_k$
  ------------- ------------- ----------------------
       $0$           $0$            $b_{k-1}$
       $0$           $1$                0
       $1$           $0$                0
       $1$           $1$       $\overline{b_{k-1}}$

若$\brace{a_n^{(1)}}$和$\brace{a_n^{(2)}}$的周期分别为$2^n-1$和$2^m-1$且$m, n$互素，$a_0^{(1)}+a_0^{(2)}=1$,
则$\brace{b_k}$的周期为$({2^n-1}({2^m-1}$

#### 钟控序列生成器

钟控序列接受两个LFSR的输入，其输入分别为序列$\brace{a_n^{(1)}}, \brace{a_n^{(2)}}$.
前一个序列控制后一个序列的时钟周期$n_k$.

其输出序列$\brace{b_k}$可以表示为

   $a_k^{(1)}$      $n_k$           $b_k$
  ------------- ------------- -----------------
       $0$        $n_{k-1}$    $a_{n_k}^{(2)}$
       $1$       $n_{k-1}+1$   $a_{n_k}^{(2)}$

若$\brace{a_n^{(1)}}$和$\brace{a_n^{(2)}}$的周期分别为$p_1$和$p_2$,
且记$\ext w=\sum_{i=0}^{p_1-1}a_i^{(1)}$,
则$\brace{b_k}$的周期为$\ext\frac{p_1p_2}{\gcd({w, p_2}}$.
若$p_1=2^m-1, p_2=2^n-1$, 则其线性复杂度为$n({2^m-1}$.

## BBS产生器

与LFSR相比，BBS产生器则需要更多的数学技巧。其步骤如下：

1.  选取两个大素数$p, q$满足$p\equiv q\equiv 3\pmod{4}$, 计算$n=pq$

2.  选取数$s$满足$({s, n}=1$

3.  令$\ext X_0=s^2\bmod{n}$

4.  伪随机比特序列$\brace{B_n}$的计算公式如下 $$\begin{gathered}
        X_i=X_{i-1}^2\bmod{n}\\
        B_i=X_i\bmod{2}
        
    \end{gathered}$$

BBS产生器是密码强度最强的伪随机数产生器。但是，与LFSR相比，BBS涉及了大素数的指数运算，因此，速度会极慢。故除非对安全性的要求极高，否则BBS产生器一般不用于实际操作中。

## ANSI X9.17伪随机数发生器

与每次产生一个比特的伪随机比特发生器不同，伪随机数发生器每次产生一个伪随机数。伪随机比特发生器是一种特殊的伪随机数发生器。伪随机比特发生器一般用于流密码，而伪随机数发生器则有更多的用途。在现实操作中，有许多地方需要随机数。比如说之后会提到的安全协议中，就大量用到了随机数。下面，我们介绍一个最为常用的伪随机数发生器：ANSI
X9.17伪随机数发生器。

### 准备阶段

同伪随机比特发生器一样，伪随机数发生器也需要一个种子。在本算法中，是一个64比特的数$V_0$.
此外，$\mathrm{DT}_i$是第$i$次计算时的日期和时间，也是一个64位的数字。

TDES是三重DES加密算法，其接受64比特的输入，产生64比特的输出,同时，TDES需要两个56比特的二进制串$K_1, K_2$作为密钥。其具体算法可参见分组密码部分。以$K_1, K_2$为密钥，用TDES加密的明文$m$记为$\mathrm{TDES}_{K_1, K_2}({m}$.

### 算法

输出的伪随机数序列$\brace{R_n}$的公式如下： $$\begin{gathered}
R_i=\mathrm{TDES}_{K_1, K_2}({V_i\oplus \mathrm{TDES}_{K_1, K_2}(\mathrm{DT}_i)}\\
V_{i+1}=\mathrm{TDES}_{K_1, K_2}(R_i\oplus \mathrm{TDES}_{K_1, K_2}(\mathrm{DT}_i))
\end{gathered}$$
