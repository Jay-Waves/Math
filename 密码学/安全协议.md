# 安全协议

## 为什么要安全协议

在第一章中，我们介绍了密码体系中的一个重要概念------密钥，同时，我们也指出了Kerckhoff准则：

提倡安全性不能建立在对算法的保密上。

那么，这一章中，我们还要提出一个概念以及一个大家一开始注意不到的准则。

我们之前提到，密钥共享的方式是也是我们研究的一个部分。这是什么意思呢？我们知道，我们研究密码学，其主要目的在于实现加密的安全通信，使得两个人之间传递的消息不会被第三个人知道。而根据我们之前对密码体系的介绍，如凯撒密码等，我们有了解到，如果要实现加密通信，通信双方必须拥有同一个密钥。一个足够好的密码体系能只让拥有密钥的人破解信息，没有拥有密钥的人永远破解不了信息。但是，仅仅如此就够了吗？我们还需要解决的是，如何让通信双方拥有同一个密钥？不仅如此，如何能让接收者确定收到的消息是来自发送者而非第三个人呢？如何保证发送者发送的消息准确地发送给了接收者而不是别的人呢？因此，一个安全的通信被分成了两个概念：通信本身文本的安全性，以及传递消息的安全性。通信本身文本的安全性，取决于加密算法、密码体系的安全性；而传递消息的安全性，则被我们称作安全协议的安全性。更直观地说，密码体系告诉我们如何将想要传递的信息变成加密的安全的消息，而安全协议告诉我们如何安全地传递这些消息。

鉴于安全通信被分为这两个层次，Dolev和Yao提出了一个准则：

安全协议与密码体系应该区分开，在假定完善的密码体系的基础上分析安全协议本身的正确性、安全性、冗余性等。首先研究安全协议本身的安全性质，然后讨论实现层次的具体细节，所采用的具体密码算法等。

此外，我们也可以形式上证明一个安全协议的安全性。Dolev和Yao发明了Dolev-Yao模型来完成这件事。但由于其需要的数学工具过于高端，这里就不再赘述。

## 安全协议记号

接下来，我们将叙述具体的安全协议。为了方便叙述，我们使用了通用的安全协议记号，即：
$$A\to B: M$$ 代表$A$发送给$B$一个消息$M$.
$$A\to B: \brace{X}_{K_{A, B}}$$
代表$A$发送给$B$一个信息，该信息是用密钥$K_{A, B}$加密明文$X$获得的密文。

安全协议分为多种类别，下面，我们首先介绍密钥协议。

## 密钥协议

### 对称密码的密钥分配

对称密码的密钥分配问题，我们主要研究的是在一个节点充分多的网络中如何建立高效、安全的信道。这个问题是有其实际意义的。试想在一个互联网公司内，有许多员工和服务器。对每个服务器，每个员工都需要利用自己的账号密码登录。那么，如果有$m$个员工和$n$个服务器，那么最原始的想法，每个员工、服务器之间都拥有一个密钥，那么总共需要$mn$个密钥。那么这能不能够优化呢？我们下面抽象该问题：

#### 点对点密钥分配

我们现在考虑有$n$个人，他们需要进行对称密码的加密通信。那么，由于每次对称密码通信都需要一个密钥，所以，最原始的想法是这$n$个人两两之间有一个密钥用于长期的加密通信。那么，这$n$个人两两加密通信就一共需要$\ext\frac{n({n-1}}{2}$个密钥。这种做法常被称作点对点密钥分配，或者称为无中心的密钥分配。其好处是安全，如果在这个加密通信网络中有一个人泄露了密钥，那么只有与这个人进行的加密通信受到影响，其他人之间的加密通信是不会受到影响的。但是，其缺点为可延展性差。密钥的数量是$O(n^2)$量级的，这导致密钥的数量会随着加密通信网络成员的增多而迅速增多。同时，新成员的加入、旧成员的减少都会影响这整个加密通信网络的成员。

在实际应用中，确实也会用点对点密钥分配的方法。但这仅仅是用于一个网络中的一小部分。在这个群体中，每两个人之间都拥有一个主密钥$K_{AB}$,
他们每次安全通信用的密钥，称为会话密钥$K_{ab}$. 其生成方法为：

1.  $A$向$B$发送如下消息： $$A\to B: \ID_A, \ID_B, N_1$$
    其中$\ID_A, \ID_B$为$A$与$B$的身份识别号,
    $N_1$是$A$生成的一个一次性随机数

2.  $B$向$A$发送如下消息：
    $$B\to A: \brace{K_{ab}, \ID_A, \ID_B, f(N_1), N_2}_{K_{AB}}$$
    其中$K_{ab}$是$B$生成的会话密钥，$K_{AB}$是$A, B$共有的主密钥,
    $f(N_1)$是一个简单的函数，比如说$f(N_1)=N_1-1$,
    目的是让$A$知道$B$确实收到了$N_1$.

3.  $A$通过$K_{AB}$解密收到的消息，并向$B$发送如下消息：
    $$A\to B:\brace{f(N_2)}_{K_{ab}}$$ 以让$B$知道$A$确实收到了$N_2$.

#### 密钥分配中心

为了弥补点对点密钥分配的缺点，我们想到的最有效的方法是将这些缺点从加密通信的双方身上转移到一个第三方机构------密钥分配中心(Key
Distribution Center, KDC). 其具体做法为：

每一个加密通信网络中的用户，都与KDC共享一个密钥，称为主密钥。因此，$n$个节点的加密通信网络中共有$n$个主密钥。在一次加密通信的过程中，加密通信双方利用主密钥，向KDC请求一个密钥，称为会话密钥。双方利用会话密钥进行加密通信。加密通信完成后，会话密钥即可销毁。

从上述过程中我们可以看到，加密通信网络的密钥数量从$O(n^2)$变为了$O(n)$,
同时新成员的加入、旧成员的减少都不会影响整个加密通信网络中的任何一个成员。

但是，KDC也有其缺点：如果KDC被成功地攻击，那么整个加密网络都会被破坏。其次，如果KDC服务暂停，那么整个网络的安全通信也会被暂停。

#### NS协议

基于KDC的密钥分配方式，其核心在于如何利用主密钥获得会话密钥。常用的方法为Needham-Schroeder协议，简称NS协议。其基本步骤为：

假设A和B要进行加密通信，$S$为KDC,
$K_{AS}, K_{BS}$分别是$A$和$B$拥有的主密钥，$\ID_A, \ID_B$分别为$A$和$B$的身份识别号，$N_A, N_B$分别为$A$和$B$产生的一个一次性随机数，$K_{AB}$为加密通信所需要的会话密钥。那么，其步骤为：

1.  $A$发送给$S$一个信息，用于确定他和$B$的身份，告诉$S$他想与$B$进行通信
    $$A\to S: \ID_A, \ID_B, N_A$$

2.  KDC, 即$S$, 生成一个$K_{AB}$,
    并将其用$K_{BS}$与一部分数据加密后返回给$A$
    $$S\to A: \brace{N_A, K_{AB}, \ID_B, \brace{K_{AB}, \ID_A}_{K_{BS}}}_{K_{AS}}$$

3.  $A$使用$K_{AS}$解密了上一步获得的密文，同时将得到的$\brace{K_{AB}, A}_{K_{BS}}$发送给$B$
    $$A\to B: \brace{K_{AB}, \ID_A}_{K_{BS}}$$

4.  $B$发送给$A$一个用$K_{AB}$加密的随机数
    $$B\to A: \brace{N_B}_{K_{AB}}$$

5.  $A$利用$K_{AB}$解密了上一步得到的密文，并将其减一后用$K_{AB}$加密发送给$B$
    $$A\to B: \brace{N_B - 1}_{K_{AB}}$$

我们在分析安全通信协议的时候，需要考虑的是，如何证明本轮收到的信息是对方发的，并且是针对自己上一轮发送信息的回馈。那么，我们从第二轮开始分析：

第二轮中，由于$K_{AS}$只有$A$和$S$知道，因此，如果能用$K_{AS}$正确解密信息，就说明获得的信息是$S$发的。同时，如果解密得到了$N_A$，就说明这次收到的信息是$S$针对上次发送的信息的回馈。

第五轮中，由于$K_{BS}$只有$B$和$S$知道，因此，只有$B$能获得第三轮中发送的$K_{AB}$.
因此，如果$B$使用$K_{AB}$解密得到的信息确实是第四步生成的随机数减一，那么就说明获得的信息确实是$A$发的，并且也确实是对之前发送信息的回馈。

但是，这样的安全通信协议可以被重放攻击。如果一个攻击者使用了一个旧的，已经被泄露出来的$K_{AB}$,
那么他可以重放信息$\brace{K_{AB}, A}_{K_{BS}}$给$B$,
从而让$B$误以为自己是$A$.
这样攻击的主要原因就在于该协议的第三步中，$B$无法确定发送者是否是当前的$A$.

在实际应用中，比如说，一个员工可以多次重复上述协议的前几步，收集其与每台服务器之间通信的$\brace{K_{AB}, \ID_A}_{K_{BS}}$.
那么即使他被解雇了，他依然可以利用这些信息来登录服务器。在这个漏洞被指出之前，这种协议被使用了持续了有快十年。

#### Kerberos

Kerberos是现在使用最广泛的一种基于对称密钥的安全通信协议。Kerberos是希腊神话中冥王哈迪斯的地狱三头犬，是MIT最初为了保护雅典娜工程提供的网络服务器而发明的。其起名为地狱三头犬也表明了这种协议十分安全。该协议现在广泛的应用于Windows,
macOS等处。
Kerberos安全通信的完整过程，是由客户向KDC发出安全通信请求，然后获得会话密钥后与特定服务器通信的过程。也就是说，先前我们提到的两个人之间的通信，在这里可以理解成一个用户$C$和一个服务器$S$之间的通信。同时，KDC中也有两个服务器：认证服务器AS和票据授权服务器TGS.
而之前提到的主密钥，在这里，则是用户$C$与TGS之间通信的密钥。

Kerberos的完整过程包括几个部分：

-   客户认证

    该部分的作用主要在于使用户$C$拥有与TGS之间通信的主密钥$K_{C, \mathrm{TGS}}$,
    在Kerberos中与之相关的一个概念是票据授权票据TGT. 其步骤为：

    1.  用户向认证服务器发送如下信息：
        $$C\to\mathrm{AS}: \ID_C, \ID_{\mathrm{TGS}}, \mathrm{IPs}, \mathrm{Lifetime}$$  
        
        其中$\ID_C, \ID_{\mathrm{TGS}}$分别是$C$与TGS的身份识别号，$\mathrm{IPs}$是$C$的IP地址范围。而Lifetime则是其申请的TGT能持续的时间。

    2.  认证服务器向用户发送如下信息：
    $$\mathbb{AS}\to C: \brace{\ID_{\mathrm{TGS}}, T_1, \mathbb{Lifetime}, K_{C, \mathbb{TGS}}}_{K_{\mathbb{User}}},$$
    $$\brace{\ID_C, \ID_{\mathbb{TGS}}, \mathbb{IPs}, T_1, \mathbb{Lifetime}, K_{C, \mathbb{TGS}}}_{K_{\mathbb{TGS}}}$$
        其中$T_1$为时间戳，$K_{\mathrm{User}}$是AS与$C$共有的一个密钥，$K_{TGS}$是AS与TGS共有的一个密钥。

        同时，$\ID_C, \ID_{\mathrm{TGS}}, \mathrm{IPs}, T_1, \mathrm{Lifetime}, K_{C, \mathrm{TGS}}$被称作票据授权票据TGT.

    3.  $C$可以利用自己拥有的$K_{\mathrm{User}}$解密获得消息的第一部分，从而获得与TGS之间通信的主密钥$K_{C, \mathrm{TGS}}$.

-   服务授权

    该部分的作用主要是使用户和TGS之间进行通信从而获得与目的服务器$S$之间通信的会话密钥$K_{C, S}$。其步骤为：

    1.  用户向票据授权服务器发送如下信息：
        $$C\to\mathrm{TGS}: \ID_{S}, \mathrm{Lifetime}, \brace{\ID_C, T_2}_{K_{C, \mathrm{TGS}}}, \brace{\mathrm{TGT}}_{K_{\mathrm{TGS}}}$$
        其中$\brace{\mathrm{TGT}}_{K_{\mathrm{TGS}}}$是用户从AS获得信息的第二部分。

    2.  票据授权服务器用$K_{\mathrm{TGT}}$解密最后一个部分，得到TGT,
        从而获得$K_{C, \mathrm{TGS}}$,
        然后解密倒数第二个部分。接着检查：

        -   TGT没有过期。

            即票据授权服务器获得信息的时间与TGT中时间戳$T_1$之间的时间差要在Lifetime允许的范围内。

        -   倒数第二个部分中的$\ID_{C}$与TGT中的$\ID_C$是一致的

        -   倒数第二个部分也没有过期。

            即票据授权服务器获得信息的时间与倒数第二个部分中的时间戳$T_2$之间的时间差要在Lifetime允许的范围内。

        -   如果IPs非空那么检查该信息的发送源IP是否在这之中。

    3.  票据授权服务器向用户发送如下信息：
        $$\mathrm{TGS}\to C: \brace{\ID_S, T_3, \mathrm{Lifetime}, K_{C, S}}_{K_{C, \mathrm{TGS}}}, \brace{\ID_C, \ID_S, \mathrm{IPs}, \mathrm{Lifetime}, K_{C, S}}_{K_{\mathrm{Server}}}$$
        其中$K_{C, S}$即为$C$与$S$通信的会话密钥，$K_{\mathrm{Server}}$是TGS与$S$共有的一个密钥。

        同时，$\ID_C, \ID_S, \mathrm{IPs}, \mathrm{Lifetime}, K_{C, S}$被称作票据Ticket.

    4.  $C$可以利用自己拥有的$K_{C, \mathrm{TGS}}$解密第一部分，从而获得$K_{C, S}$

-   服务请求

    该部分是用户与目的服务器之间建立安全信道通信。其步骤为：

    1.  用户向目的服务器发送如下信息：
        $$C\to S: \brace{\ID_C, T_4}_{K_{C, S}}, \brace{\mathrm{Ticket}}_{K_{\mathrm{Server}}}$$
        其中后半部分是$C$之前收到的信息

    2.  $S$用自己拥有的$K_{\mathrm{Server}}$密钥解密第二部分，获得$K_{C, S}$解密第一部分，然后检查：

        -   Ticket没有过期。

            即服务器获得信息的时间与时间戳$T_2$之间的时间差要在Lifetime允许的范围内。

        -   第一部分中的$\ID_C$与第二部分中的$\ID_C$是一致的

        -   第一部分也没有过期。

            即服务器获得信息的时间与时间戳$T_4$之间的时间差在Lifetime允许的范围内。

        -   如果IPs非空那么检查该信息的发送源IP是否在这之中。

由于Kerberos涉及了许多密钥，下面这张表格给出了每一个参与者获得相应密钥的步骤

         $K_{\mathrm{User}}$   $K_{\mathrm{TGS}}$   $K_{\mathrm{Server}}$   $K_{C, \mathrm{TGS}}$   $K_{C, S}$
  ----- --------------------- -------------------- ----------------------- ----------------------- ------------
    C         预先获得                                                            客户认证3         服务授权4
   AS         预先获得              预先获得                                      由其生成         
   TGS                              预先获得              预先获得                服务授权2          由其生成
    S                                                     预先获得                                  服务请求2

### 公钥密码体系的安全协议

在介绍对称密码时，我们提到，安全协议是为了解决如何使通信双方拥有密钥，以及如何验证对方身份的问题。在公钥密码体系中，这个问题就变成了，如何使发送方拥有公钥，以及如何验证对方身份。

由于公钥不需要保密，因此，在一个网络中使每个节点拥有自己的公钥的方法有两种：

-   公开发布

    向整个网络广播自己的公钥。

-   公钥目录表

    该网络的管理员维护一个公钥目录表，其包含了该网络的节点和该节点对应的公钥。

然而，这两种方法有一个漏洞：如果$B$用自己的公钥伪造了$A$的公钥，同时截获了发给$A$的信息，那么所有发给$A$的秘密信息都可以被$B$获知。下面，介绍一种既可以验证身份，又可以分配密钥的方法：数字证书。

数字证书就相当于安全通信网络中的身份证。其由可靠的机构颁发。正如我们可以通过身份证确定对方的身份，我们可以利用数字证书来验证安全通信双方的身份。X.509是当前通行的数字证书的格式标准，本节中数字证书的内容都是参照X.509标准。

首先，我们来看看数字证书中包含了什么。

-   （可选）版本号

    X.509标准有三个版本。现在通用的是v3版本

-   序列号

    类似于身份证号，每个数字证书对应一个唯一的序列号

-   签名算法

    发布者用于签名该证书的算法。常用的有带RSA加密的SHA-256，带RSA的MD5等

-   颁发者

-   证书有效期

    包括此日期前无效、此日期后无效

-   主体

    拥有该数字证书的个体的名称

-   主体公钥信息

    包含主体拥有的公钥以及相应的算法标识

-   （可选）颁发者唯一身份信息

-   （可选）主体唯一身份信息

-   （可选）扩展信息

我们可以发现，数字证书中包含该主体的公钥。因此，数字证书也可以进行公钥的分配。

### 基于公钥密码的会话密钥分配协议

相比于对称密码，公钥密码有起不可比拟的好处。公钥密码可以在不安全的信道中实现安全通信。但是，由于涉及到复杂的运算，因此公钥密码的加密速度极慢。考虑到在对称密码中的安全通信需要保护两个东西：明文和密钥。因此，公钥密码被用在了另一个地方：对称密码体系的密钥分配。安全通信双方可以先通过公钥密码体系来获得一个共享的会话密钥，再利用会话密钥来对称加密明文，达到既安全又高效的效果。在基于公钥密码的会话密钥的分配方法中，最常用的就是Diffie-Hellman密钥交换协议。

类似于ElGamal密码，Diffie-Hellman密钥交换协议是基于离散对数问题。首先，我们回忆一下一些基本概念：

对于群$G$及$G$上的运算$\cdot$,
将$n$个$g$相运算$g\cdot g\cdot \cdots \cdot g$的结果记作$g^n$.

如果存在一个元素$g\in G$, 使得对于任意元素$x\in G$, 存在$n$使得$a=g^n$,
则称$G$为循环群，$g$为$G$的生成元。

如果$G$的元素有$q$个，则称$G$是$q$阶的。

而数论知识告诉我们，若整数$n$是奇素数的幂$p^k$,
那么整数模$n$乘法群$\Z/n\Z=\{m\mid ({m, n}=1, 0\leq m\leq n-1\}$对于模$n$乘法构成一个循环群。因此，如果要形象理解Diffie-Hellman密钥交换协议，不妨把其中的循环群理解成整数模$n$乘法群。

Diffie-Hellman密钥交换的具体步骤为：

假设$A$与$B$想要共享一个会话密钥。

1.  $A$与$B$协定一个有限循环群$G$和它的一个生成元$g$

2.  $A$选取一个随机数$a\in\mathbb{N}$, 并向$B$发送消息： $$A\to B: g^a$$

3.  $B$选取一个随机数$b\in\mathbb{N}$, 并向$A$发送消息： $$B\to A: g^b$$

4.  $A$通过计算获得密钥$K$ $$K=({g^b}^a$$

5.  $B$通过计算获得密钥$K$ $$K=({g^a}^b$$

更具体地，如果对于整数模$n$乘法循环群来说，其步骤为：

1.  $A$与$B$协定一个素数$p$和$\Z/p\Z$的一个生成元$g$

2.  $A$选取一个随机数$a\in\mathbb{N}$, 并向$B$发送消息：
    $$A\to B: g^a\bmod{p}$$

3.  $B$选取一个随机数$b\in\mathbb{N}$, 并向$A$发送消息：
    $$B\to A: g^b\bmod{p}$$

4.  $A$通过计算获得密钥$K$ $$K=({g^b\bmod{p}}^a\bmod{p}$$

5.  $B$通过计算获得密钥$K$ $$K=({g^a\bmod{p}}^b\bmod{p}$$

### 秘密共享

#### 定义

我们考虑一个问题：一共有$n$个人参与一项秘密的工程，他们将文件锁在一个保险柜里，这个保险柜只有在不少于$m$个相关的人在场的情况下才能被打开。那么至少需要多少把锁？每个人至少要携带多少把钥匙？

运用组合数学的知识，我们可以知道，至少需要$C_n^m$把锁，而每个人至少需要携带$C_{n-1}^{m-1}$把钥匙。

假设一共有$11$个人，而这个保险柜只有在不少于$6$人的情况下才能被打开，那么至少需要$462$把锁，每个人至少携带$252$把钥匙。这无疑是一个巨大的数字。而这种情况在现实中却是真实存在的，如一个国家的核按钮必须由多个人在场的情况下才能被使用。那么，有没有更简易的方法能实现这个目的呢？这就需要使用密码学中Shamir提出的的秘密共享理论。

其正式定义如下：

假设要被分享的秘密为数据$D$, 将其分为$n$个份额$D_1, D_2,\ldots, D_n$,
满足：

-   如果获得大于等于$k$个份额$D_i$, 那么计算$D$是容易的

-   如果获得小于等于$k-1$个份额$D_i$, 那么不可以计算$D$

称这种方案为一个$({k, n}$门限方案，$k$称为门限值。

要讨论一个秘密共享方案，其包含两个方面：秘密的分割与秘密的恢复。秘密的分割即为将秘密分为$n$个份额，而秘密的恢复即为使用$k$个份额恢复秘密。

#### 完善性

类似于我们在密码体制的安全性时的讨论，我们也可以定义一个秘密共享的完善性。其文字化的叙述如下：

::: Definition
如果一个参与者或一组未经授权的参与者在猜测被共享的秘密时，并不比局外人猜秘密时有优势，即：少于$k$个参与者所持有的部分秘密信息得不到秘密$D$的任何信息，则称该秘密共享方案是完善的。
:::

事实上，也是存在完善的秘密共享方案的数学形式化定义，其也类似于密码体制的安全性，通过引入秘密空间、份额空间，并利用一些概率公式来描述。这里就不再赘述。

类似于无条件安全的密码体制，无条件安全的秘密共享方案也需要满足一个条件：

::: theorem
一个秘密共享方案是无条件安全的当且仅当它的秘密空间大小与其份额空间大小相同。
:::

用通俗的话来说，如果一个秘密共享方案需要共享的秘密是一个长度为$n$比特的二进制串，那么每个参与者获得的份额也至少是$n$比特的二进制串。

#### Shamir门限方案

Shamir提出了一种$({k, n}$门限方案：

假设被共享的秘密为$D$,
要生成的门限方案为$({k, n}$门限方案，$n$个参与者分别为$P_1, P_2,\ldots, P_n$.

1.  选取一个大素数$p\geq n+1, p>D$. 构造有限域$\GF({p}$

2.  在$\GF({p}$内随机选取$k-1$个非零元素$a_1, a_2,\ldots, a_{k-1}$

3.  构造函数$f({x}=D+a_1x+a_2x^2+\cdots +a_{k-1}x^{k-1}$,
    其中的运算均为$\GF({p}$上的运算

4.  对于第$i$个参与者，其获得的份额为$({i, f(i)}$

假设集齐了$k$个参与者$P_{i_1}, P_{i_2}, \ldots, P_{i_k}$,
那么秘密可以由以下公式计算：
$$D=({-1}^{k-1}\sum_{j=1}^kf(i_j)\prod_{1\leq l\leq k, l\neq j}i_l\cdot({i_j-i_l}^{-1}$$
其中的所有运算都是$\GF({p}$上的运算。
首先论证秘密确实可以由上述公式恢复：

对于这$k$个参与者获得的份额，根据其分割的公式，可以得到以下线性方程组：
$$\begin{dcases}
D+a_1i_1+a_2i_1^2+\cdots +a_{k-1}i_1^{k-1}=f(i_1)\\
D+a_1i_2+a_2i_2^2+\cdots +a_{k-1}i_2^{k-1}=f(i_2)\\
\cdots\\
D+a_1i_k+a_2i_k^2+\cdots +a_{k-1}i_k^{k-1}=f(i_k)
\end{dcases}$$

这是关于$({D, a_1, a_2,\ldots, a_{k-1}}$的$k$个$k$元线性方程组。根据Lagrange插值公式：
$$f({x}=\sum_{j=1}^kf(i_j)\prod_{1\leq l\leq k, l\neq j}({x-i_l}\cdot({x_j-x_l}^{-1}$$

其中的运算都是$\GF({p}$上的运算。

因此，
$$D=f(0)=({-1}^{k-1}\sum_{j=1}^kf(i_j)\prod_{1\leq l\leq k, l\neq j}i_l\cdot({i_j-i_l}^{-1}$$

接下来论证$k-1$个参与者不可以获得秘密：

根据秘密分割的公式，$k-1$个参与者只能得到$k-1$个$k$元线性方程组，其在$\GF({p}$上的解$D$有$p$个。因此，其获得不了关于$D$的任何信息。

#### 基于中国剩余定理的门限方案

假设被共享的秘密为$D$,
要生成的门限方案为$({k, n}$门限方案，$n$个参与者分别为$P_1, P_2,\ldots, P_n$.

1.  选取$n$个大于1的整数$m_1, m_2, \ldots, m_n$, 满足：

    -   $m_1<m_2<\cdots <m_n$

    -   $\forall i\neq j, ({m_i, m_j}=1$

    -   $m_1m_2\cdots m_k>D>m_{n-k+2}m_{n-k+3}\cdots m_n$

2.  计算$M=m_1m_2\cdots m_n$

3.  计算$s_i=D\bmod{m_i}, i=1, 2,\ldots, n$

4.  对于第$i$个参与者，其份额为$({s_i, m_i, M}$

假设集齐了$k$个参与者$P_{i_1}, P_{i_2}, \ldots, P_{i_k}$,
那么秘密可以由以下方法

1.  计算$\ext M_{i_j}=\frac{M}{m_{i_j}}$,
    $N_{i_j}$是$M_{i_j}$模$m_{i_j}$的逆，$y_{i_j}=s_{i_j}M_{i_j}N_{i_j}$

2.  秘密的计算公式为
    $$D=\sum_{j=1}^ky_{i_j}\bmod{\prod_{j=1}^km_{i_j}}$$

首先论证秘密确实可以恢复：

根据秘密分割的公式，我们可以得到以下同余方程组： $$\begin{dcases}
D\equiv s_{i_1}\pmod{m_{i_1}}\\
D\equiv s_{i_2}\pmod{m_{i_2}}\\
\cdots\\
D\equiv s_{i_k}\pmod{m_{i_k}}
\end{dcases}$$

运用中国剩余定理，即可得到
$$D\equiv\sum_{j=1}^ky_{i_j}\pmod{\prod_{j=1}^km_{i_j}}$$

下面证明 $$D=\sum_{j=1}^ky_{i_j}\bmod{\prod_{j=1}^km_{i_j}}$$

由秘密分割的公式，$D$是同余方程组 $$\begin{dcases}
D\equiv s_{1}\pmod{m_{1}}\\
D\equiv s_{2}\pmod{m_{2}}\\
\cdots\\
D\equiv s_{n}\pmod{m_{n}}
\end{dcases}$$ 的解。

记$\ext D'=\sum_{j=1}^ky_{i_j}\bmod{\prod_{j=1}^km_{i_j}}$,
那么有$\forall 1\leq j\leq k, D'\equiv D\pmod{s_{i_j}}$.
因此，$m_{i_j}\mid D'-D$. 故
$$\brack{m_{i_1}, m_{i_2}, \ldots, m_{i_k}}=\prod_{j=1}^km_{i_j}\mid D'-D$$
故 $$D'\equiv D\pmod{m_{i_1}m_{i_2}\cdots m_{i_k}}$$

又由于$D', D<m_1m_2\cdots m_k\leq m_{i_1}m_{i_2}\cdots m_{i_k}$,
故$D'=D$.

此外，如果参与者少于$k$个，不妨设为$k-1$个，那么所建立的方程组的解
$$D'=\sum_{j=1}^{k-1}y_{i_j}\bmod{\prod_{j=1}^{k-1}m_{i_j}}$$ 满足
$$D'<m_{i_1}m_{i_2}\cdots m_{i_{k-1}}<m_{n-k+2}m_{n-k+3}\cdots m_n<D$$
故不是秘密。
